#!/usr/bin/env node

const Mocha = require('mocha');
const pti = require('puppeteer-to-istanbul');
const listen = require('../test-server');
const exec = require('../exec');

const ignoreGlobal = ['SifrrDom', 'SifrrRoute', 'SifrrCli'];

global.fs = require('fs');
global.path = require('path');
global.chai = require('chai');
global.assert = chai.assert;
global.expect = chai.expect;
global.should = chai.should();
global.puppeteer = require('puppeteer');
global.port = 9999;
global.PATH = `http://localhost:${port}`;

// Check if need coverage
const toCover = process.env.COVERAGE === 'true';

const nycReport = path.join(__dirname, '../../.nyc_output');
const loadBrowser = async function() {
  // set browser and page global variables
  let pBrowser = await puppeteer.launch({
    // to make it work in circleci
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox'
    ],
    headless: process.env.HEADLESS !== 'false',
    devtools: false
  });
  let page = await pBrowser.newPage();
  if (toCover) await page.coverage.startJSCoverage();
  await page.setViewport( { width: 1280, height: 800} );
  global.browser = {
    close: async () => {
      if (!toCover) return pBrowser.close();
      const jsCoverage = await page.coverage.stopJSCoverage();
      pti.write(jsCoverage, path.join(nycReport, `./separate/${Date.now()}-coverage.json`));
      return pBrowser.close();
    }
  };
  if (toCover) {
    page.goto = async (url, options) => {
      const jsCoverage = await page.coverage.stopJSCoverage();
      pti.write(jsCoverage, path.join(nycReport, `./separate/${Date.now()}-coverage.json`));
      const ret = page.mainFrame().goto(url, options);
      await page.coverage.startJSCoverage();
      return ret;
    };
  }
  global.page = page;

  return true;
};

const dir = path.join(__dirname, '../../', process.argv[2]);

const mochaOptions = {
  timeout: 10000
};
const useJunitReporter = process.argv.indexOf('-j') > 0 || process.argv.indexOf('--junit') > 0;
const junitXmlFile = path.join(__dirname, `../../test-results/${dir.split(path.sep).pop()}/results.xml`);

if (useJunitReporter) {
  mochaOptions.reporter = 'mocha-junit-reporter';
  mochaOptions.reporterOptions = {
    mochaFile: junitXmlFile
  };
}

const mocha = new Mocha(mochaOptions);

// check if run only unit test
const runUnitTests = process.argv.indexOf('-u') > 0 || process.argv.indexOf('--unit') > 0;
const unitTestDir = path.join(dir, './test/unit');

// check if run only browser tests
const runBrowserTests = process.argv.indexOf('-b') > 0 || process.argv.indexOf('--browser') > 0;
const browserTestDir = path.join(dir, './test/browser');

// add main package to global
const pkg = require(path.join(dir, './package.json'));
const name = pkg.name.replace(/^@sifrr\/([a-z])(.*)$/, (m, l, r) => `Sifrr${l.toUpperCase()}${r}`);
if (ignoreGlobal.indexOf(name) < 0) global[name] = require(path.join(dir, pkg.main));

// Relative to base requiring
global.requireBase = (pt) => require(path.join(dir, pt));

(async function() {
  try {
    let ser = false;

    // clear coverage
    // await exec(`rm -rf ${nycReport}`);

    if ((runUnitTests || !runBrowserTests) && fs.existsSync(unitTestDir)) {
      // Add unit test.js files to the mocha instance
      loadDir(unitTestDir);
    }

    if ((runBrowserTests || !runUnitTests) && fs.existsSync(browserTestDir)) {
      const testPublicPath = path.join(dir, './test/public');

      // Run yarn rollup if there is a rollup config in public folder
      if (fs.existsSync(path.join(testPublicPath, './rollup.config.js'))) await exec(`cd ${testPublicPath} && ../../node_modules/.bin/rollup -c`);

      // Start server if there is a public folder
      if (fs.existsSync(path.join(testPublicPath))) ser = listen(port, testPublicPath);

      // Add browser test.js files to the mocha instance
      loadDir(browserTestDir);

      // load browser
      await loadBrowser();
    }

    mocha.run((failures) => {
      // close server if open
      if (ser) ser.close();

      if (failures) {
        process.stdout.write(`---------- ${failures} FAILURES. ----------\n`);
        process.exitCode = 1;  // exit with non-zero status if there were failures
      }

      // close browser
      if (global.browser) browser.close();

      // Merge code coverage
      if (toCover) fixCoverage();
    });
  } catch(e) {
    process.exitCode = 1;
    throw e;
  }
})();


function loadDir(dir, fxn) {
  fs.readdirSync(dir).forEach(file => {
    const filePath = path.join(dir, file);
    fs.statSync(filePath).isDirectory()
      ? loadDir(filePath)
      : fxn ? fxn(filePath) : mocha.addFile(filePath);
  });
}

async function fixCoverage() {
  const fileName = `${Date.now()}-full-coverage.json`;
  if (fs.existsSync(`${nycReport}/separate`)) {
    await exec(`nyc merge ${nycReport}/separate ${nycReport}/${fileName}`);
    await exec(`find ${nycReport}/separate -name "*.json" -delete`);
  }

  function fileParse(filePath) {
    if (path.extname(filePath) !== '.json') return;
    if (filePath.indexOf('full-coverage.json') > 0) return;
    const fileContents = require(filePath);
    for (let file in fileContents) {
      const branchStats = fileContents[file].b,
        branchMeta = fileContents[file].branchMap;
      if (!branchStats) {
        return;
      }

      Object.keys(branchStats).forEach((branchName) => {
        if (!branchMeta[branchName]) {
          delete branchStats[branchName];
        }
      });

    }

    fs.writeFileSync(filePath, JSON.stringify(fileContents));
  }

  fileParse(`${nycReport}/${fileName}`);

  const allFiles = [];
  loadDir(nycReport, (file) => allFiles.push(file));
  allFiles.forEach(async (file) => {
    if (file.indexOf('full-coverage.json') < 0) await exec(`rm ${file}`);
  });
}
