#!/usr/bin/env node

const Mocha = require('mocha');
const listen = require('../../test-server');

const ignoreGlobal = ['SifrrDom', 'SifrrRoute'];

global.fs = require('fs');
global.path = require('path');
global.chai = require('chai');
global.exec = require('../exec');
global.assert = chai.assert;
global.expect = chai.expect;
global.should = chai.should();
global.puppeteer = require('puppeteer');
global.port = 9999;
global.PATH = `http://localhost:${port}`;
global.loadBrowser = async function() {
  // set browser and page global variables
  let browser = await puppeteer.launch({
    // to make it work in circleci
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox'
    ],
    headless: process.env.HEADLESS !== 'false',
    devtools: false
  });
  let page = await browser.newPage();
  await page.setViewport( { width: 1280, height: 800} );
  global.browser = browser;
  global.page = page;
  return true;
};
global.pti = require('puppeteer-to-istanbul');

const dir = path.join(__dirname, '../../', process.argv[2]);

const mochaOptions = {
  timeout: 10000
};
const useJunitReporter = process.argv.indexOf('-j') > 0 || process.argv.indexOf('--junit') > 0;
const junitXmlFile = path.join(__dirname, `../../test-results/${dir.split(path.sep).pop()}/results.xml`);

if (useJunitReporter) {
  mochaOptions.reporter = 'mocha-junit-reporter';
  mochaOptions.reporterOptions = {
    mochaFile: junitXmlFile
  };
}

const mocha = new Mocha(mochaOptions);

// check if run only unit test
const runUnitTests = process.argv.indexOf('-u') > 0 || process.argv.indexOf('--unit') > 0;
const unitTestDir = path.join(dir, './test/unit');

// check if run only browser tests
const runBrowserTests = process.argv.indexOf('-b') > 0 || process.argv.indexOf('--browser') > 0;
const browserTestDir = path.join(dir, './test/browser');

// add main package to global
const pkg = require(path.join(dir, './package.json'));
const name = pkg.name.replace(/^@sifrr\/([a-z])(.*)$/, (m, l, r) => `Sifrr${l.toUpperCase()}${r}`);
if (ignoreGlobal.indexOf(name) < 0) global[name] = require(path.join(dir, pkg.main));

(async function() {
  try {
    let ser = false;

    if ((runUnitTests || !runBrowserTests) && fs.existsSync(unitTestDir)) {
      // Add unit test.js files to the mocha instance
      loadDir(unitTestDir);
    }

    if ((runBrowserTests || !runUnitTests) && fs.existsSync(browserTestDir)) {
      const testPublicPath = path.join(dir, './test/public');

      // Run yarn rollup if there is a rollup config in public folder
      if (fs.existsSync(path.join(testPublicPath, './rollup.config.js'))) await exec(`cd ${testPublicPath} && ../../node_modules/.bin/rollup -c`);

      // Start server if there is a public folder
      if (fs.existsSync(path.join(testPublicPath))) ser = listen(port, testPublicPath);

      // Add browser test.js files to the mocha instance
      loadDir(browserTestDir);
    }

    mocha.run((failures) => {
      // close server if open
      if (ser) ser.close();

      if (failures) {
        process.stdout.write(`---------- ${failures} FAILURES. ----------\n`);
        process.exitCode = 1;  // exit with non-zero status if there were failures
      }
    });
  } catch(e) {
    process.exitCode = 1;
    throw e;
  }
})();

function loadDir(dir) {
  fs.readdirSync(dir).filter(function(file) {
    // Only keep the `test.js` suffixed files
    return file.substr(-7) === 'test.js';
  }).forEach(function(file) {
    mocha.addFile(
      path.join(dir, file)
    );
  });
}

function deepProxy() {
  const target = ({}).constructor;
  const handler = {
    get: () => new Proxy(target, handler),
    set: () => true,
    apply: () => new Proxy(target, handler),
    construct: () => new Proxy(target, handler)
  };
  return new Proxy(target, handler);
}
