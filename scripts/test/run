#!/usr/bin/env node

const Mocha = require('mocha');
const pti = require('puppeteer-to-istanbul');
const listen = require('../test-server');
const exec = require('../exec');
const loadDir = require('./loaddir');
const testLoader = require('./testloader');

global.fs = require('fs');
global.path = require('path');
global.chai = require('chai');
global.assert = chai.assert;
global.expect = chai.expect;
global.should = chai.should();
global.puppeteer = require('puppeteer');
global.port = 9999;
global.PATH = `http://localhost:${port}`;

// Check if need coverage
const toCover = process.env.COVERAGE === 'true';

const nycReport = path.join(__dirname, '../../.nyc_output');
const loadBrowser = async function() {
  // set browser and page global variables
  let pBrowser = await puppeteer.launch({
    // to make it work in circleci
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox'
    ],
    headless: process.env.HEADLESS !== 'false',
    devtools: false
  });
  let page = await pBrowser.newPage();
  if (toCover) await page.coverage.startJSCoverage();
  await page.setViewport( { width: 1280, height: 800} );
  global.browser = {
    close: async () => {
      if (!toCover) return pBrowser.close();
      const jsCoverage = await page.coverage.stopJSCoverage();
      pti.write(jsCoverage, path.join(nycReport, `./separate/${Date.now()}-coverage.json`));
      return pBrowser.close();
    }
  };
  if (toCover) {
    page.goto = async (url, options) => {
      const jsCoverage = await page.coverage.stopJSCoverage();
      pti.write(jsCoverage, path.join(nycReport, `./separate/${Date.now()}-coverage.json`));
      const ret = page.mainFrame().goto(url, options);
      await page.coverage.startJSCoverage();
      return ret;
    };
  }
  global.page = page;

  return true;
};

const mochaOptions = {
  timeout: 10000
};

const useJunitReporter = process.argv.indexOf('-j') > 0 || process.argv.indexOf('--junit') > 0;
// const junitXmlFile = path.join(__dirname, `../../test-results/${dir.split(path.sep).pop()}/results.xml`);

if (useJunitReporter) {
  mochaOptions.reporter = 'mocha-junit-reporter';
  mochaOptions.reporterOptions = {
    // mochaFile: junitXmlFile
  };
}

const mocha = new Mocha(mochaOptions);

// check if run only unit test
const runUnitTests = process.argv.indexOf('-u') > 0 || process.argv.indexOf('--unit') > 0;

// check if run only browser tests
const runBrowserTests = process.argv.indexOf('-b') > 0 || process.argv.indexOf('--browser') > 0;

// Relative to base requiring
// global.requireBase = (pt) => require(path.join(dir, pt));

(async function() {
  try {
    let ser = false;

    const dirs = process.argv[2].split(',').filter(x => !!x);
    const pubPs = await dirs
      .map(async dir => await testLoader(dir, mocha, { runUnitTests, runBrowserTests }));
    const pubPaths = (await Promise.all(pubPs)).filter(x => !!x);
    if (pubPaths.length > 0) {
      ser = listen(port, pubPaths);
    }

    if (runBrowserTests || !runUnitTests) {
      await loadBrowser();
    }

    mocha.run((failures) => {
      // close server if open
      if (ser) ser.close();

      if (failures) {
        process.stdout.write(`---------- ${failures} FAILURES. ----------\n`);
        process.exitCode = 1;  // exit with non-zero status if there were failures
      }

      // close browser
      if (global.browser) browser.close();

      // Merge code coverage
      if (toCover) fixCoverage();
    });
  } catch(e) {
    process.exitCode = 1;
    throw e;
  }
})();

// Filter out clutter, map to real files
async function fixCoverage() {
  const fileName = `${Date.now()}-full-coverage.json`;
  if (fs.existsSync(`${nycReport}/separate`)) {
    await exec(`nyc merge ${nycReport}/separate ${nycReport}/${fileName}`);
    fileParse(`${nycReport}/${fileName}`);
  }

  function fileParse(filePath) {
    if (path.extname(filePath) !== '.json') return;
    if (filePath.indexOf('full-coverage.json') < 0) return;
    const fileContents = require(filePath);
    for (let file in fileContents) {
      if (file.indexOf('sifrr.') < 0 || file.indexOf('unpkg') >= 0) {
        delete fileContents[file];
      } else {
        const branchStats = fileContents[file].b,
          branchMeta = fileContents[file].branchMap;
        if (!branchStats) {
          return;
        }

        Object.keys(branchStats).forEach((branchName) => {
          if (!branchMeta[branchName]) {
            delete branchStats[branchName];
          }
        });

        const newPath = fileContents[file].path.replace(/\.nyc_output\/separate\/js\/.*\/sifrr\.([^.]*)(\.module)?\.js$/, 'packages/browser/sifrr-$1/dist/sifrr.$1$2.js');
        fileContents[newPath] = Object.assign({}, fileContents[file]);
        fileContents[newPath].path = newPath;
        delete fileContents[file];
      }
    }

    fs.writeFileSync(filePath, JSON.stringify(fileContents));
  }

  const allFiles = [];
  loadDir(nycReport, (file) => allFiles.push(file));
  allFiles.forEach(async (file) => {
    if (file.indexOf('full-coverage.json') < 0 && file.indexOf('separate/js') < 0) await exec(`rm ${file}`);
  });
}
