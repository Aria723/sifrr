<template>
  <style>
    :host {
      display: none;
    }
    :host(.active) {
      display: block;
    }
  </style>
  <slot></slot>
</template>
<script>
  let sfRoute = SFComponent['sf-route'];
  sfRoute.connectedCallback = function(el) {
    el.slotHTML = el.cloneNode(true);
    refreshRoute(el, window.location.pathname);
  }
  sfRoute.observedAttributes = ['data-route'];
  sfRoute.attributeChangedCallback = function(el, attrName, oldVal, newVal) {
    if (attrName == 'data-route') {
      refreshRoute(el, window.location.pathname);
    }
  }

  let clickEvents = {};
  clickEvents['a'] = function(el, e) {
    if (el.host == window.location.host) {
      e.preventDefault();
      var stateObj = {
        location: el.pathname
      };
      document.title = el.pathname;
      history.pushState(stateObj, "Home", el.pathname);
      refreshAllRoutes();
    }
  }

  window.onpopstate = function(event) {
    refreshAllRoutes();
  };

  function refreshAllRoutes() {
    let path = window.location.pathname;
    document.querySelectorAll('sf-route').forEach(function(el) {
      refreshRoute(el, path);
    });
  }

  function refreshRoute(el, path) {
    let route = el.dataset.route;
    let active = false;
    let parsed = parseRoute(route, path);
    parsed.match ? makeRouteActive(el, parsed.data) : makeRouteInactive(el);
  }

  function parseRoute(route, path) {
    let reg = new RegExp('^' + route.replace(/\*\*/, '.{0,}').replace(/\*/g, '[^\/]{0,}').replace(/:[^\/]{0,}/g, '[^\/]{0,}'));
    let pathSplit = SFComponent.getRoutes(path);
    let data = {
      star: []
    };
    for (const [i, r] of SFComponent.getRoutes(route).entries()) {
      if (r[0] == ':') {
        data[r.substr(1)] = pathSplit[i];
      } else if (r == '*') {
        data.star.push(pathSplit[i]);
      }
    }
    return {
      match: path.match(reg),
      data: data
    }
  }

  function makeRouteActive(el, route) {
    try {
      let lazyComps = JSON.parse(el.dataset.lazy);
      new SFComponent(lazyComps);
    } catch (e) {
      console.log(e);
    }
    SFComponent.replaceNode(el.slotHTML, el, {
      route: route
    });
    addClass(el, 'active');
  }

  function makeRouteInactive(el) {
    removeClass(el, 'active');
  }

  function addClass(elem, classN) {
    elem = typeof elem == "string" ? elem = document.querySelector(elem) : elem;
    if (!elem) {
      return false;
    }
    elem.classList.add(classN);
  }

  function removeClass(elem, classN) {
    elem = typeof elem == "string" ? elem = document.querySelector(elem) : elem;
    if (!elem) {
      return false;
    }
    elem.classList.remove(classN);
  }

  //Click event listner
  const MAIN = document.body || document.getElementsByTagName("body")[0];

  function clickHandler(e) {
    e = e || window.event;
    var target;
    target = e.target || e.srcElement;
    for (var k in clickEvents) {
      x = target;
      while (x) {
        if (x.matches(k)) {
          var fn = clickEvents[k];
          if (typeof fn === "function") {
            fn(x, e);
          }
        }
        if (x) {
          x = x.parentElement;
        }
      }
    }
  }

  if (MAIN.addEventListener) {
    MAIN.addEventListener('click', clickHandler, false);
  } else {
    MAIN.attachEvent('onclick', clickHandler);
  }

  Array.prototype.remove = function() {
    let what, a = arguments,
      L = a.length,
      ax;
    while (L && this.length) {
      what = a[--L];
      while ((ax = this.indexOf(what)) !== -1) {
        this.splice(ax, 1);
      }
    }
    return this;
  };
</script>