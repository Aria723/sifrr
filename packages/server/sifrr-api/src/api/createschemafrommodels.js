const fs = require('fs');
const path = require('path');
const mkdirp = require('mkdirp');
const attrsToTypes = require('./attrstotypes');
const flatten = require('./flatten');
const { makeExecutableSchema } = require('graphql-tools');

function getTypeDef(qs, resolvers) {
  for (let q in qs) {
    const qdet = qs[q];
    resolvers[q] = qdet.resolver;
  }
  return flatten(attrsToTypes(qs), '\n  ');
}

function createSchemaFromModels(models, { extra = '', query = {}, mutation = {}, saveSchema = true, schemaPath = './db/schema.graphql' } = {}) {
  const typeDefs = [], resolvers = {};
  for(let modelName in models) {
    typeDefs.push(`type ${models[modelName].gqName} {
  ${flatten(models[modelName].gqSchema(), '\n  ')}
}`);
    Object.assign(resolvers, models[modelName].resolvers);
    Object.assign(query, models[modelName].resolvers.Query);
    Object.assign(mutation, models[modelName].resolvers.Mutation);
  }
  Object.assign(resolvers.Query, query);
  Object.assign(resolvers.Mutation, mutation);

  const qnew = {}, mnew = {};

  const typeDef = `type Query {
  ${getTypeDef(resolvers.Query, qnew)}
}

type Mutation {
  ${getTypeDef(resolvers.Mutation, mnew)}
}

scalar SequelizeJSON
scalar Date
${extra}`;

  typeDefs.unshift(typeDef);
  resolvers.Query = qnew;
  resolvers.Mutation = mnew;

  if (saveSchema) {
    schemaPath = path.resolve(schemaPath);
    mkdirp(path.dirname(schemaPath));
    const comment = '# THIS FILE WAS AUTOGENERATED BY SIFRR-API. DO NOT EDIT THIS FILE DIRECTLY. \n\n';
    fs.writeFileSync(schemaPath, comment + typeDefs.join('\n\n') + '\n');
  }

  return makeExecutableSchema({
    typeDefs,
    resolvers
  });
}

module.exports = createSchemaFromModels;
