{"version":3,"file":"sw.bundled.js","sources":["sw.js","../../dist/sifrr.serviceworker.js"],"sourcesContent":["const SW = require('../../dist/sifrr.serviceworker');\nconst sw = new SW({\n  version: 2,\n  fallbackCacheName: 'ffff',\n  defaultCacheName: 'dddd',\n  policies: {\n    'cachefirst': {\n      policy: 'CACHE_FIRST'\n    },\n    'networkfirst': {\n      policy: 'NETWORK_FIRST',\n      cacheName: 'bangbang'\n    },\n    'networkonly': {\n      policy: 'NETWORK_ONLY'\n    },\n    'cacheonly': {\n      policy: 'CACHE_ONLY',\n      cacheName: 'bangbang2'\n    },\n  },\n  fallbacks: {\n    'default': '/404.html'\n  },\n  precache_urls: ['/precache.js', './cacheonly.js']\n});\n\nsw.setup();\nsw.setupPushNotification('default title', { body: 'default body' });\nmodule.exports = sw;\n","/*! Sifrr.Serviceworker v0.0.1-alpha - sifrr project - 2018/12/26 15:18:15 UTC */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Sifrr = global.Sifrr || {}, global.Sifrr.Serviceworker = factory());\n}(this, (function () { 'use strict';\n\n  class SW {\n    constructor(options) {\n      this.options = Object.assign({\n        version: 1,\n        fallbackCacheName: 'fallbacks',\n        defaultCacheName: 'default',\n        policies: {},\n        fallbacks: {},\n        precacheUrls: []\n      }, options);\n      this.options.policies.default = Object.assign(this.options.policies.default || {}, {\n        policy: 'NETWORK_FIRST',\n        cacheName: this.options.defaultCacheName\n      });\n      this.options.fallbacks.default = this.options.fallbacks.default || '/offline.html';\n    }\n    precache(urls = this.options.precacheUrls, fbs = this.options.fallbacks) {\n      const me = this;\n      let promises = [];\n      urls.forEach(u => {\n        let req = me.requestFromURL(u);\n        return promises.push(me.responseFromNetwork(req, me.findRegex(u, me.options.policies).cacheName || me.options.defaultCacheName));\n      });\n      for (let value of Object.values(fbs)) {\n        let req = this.requestFromURL(value);\n        promises.push(this.responseFromNetwork(req, this.options.fallbackCacheName));\n      }\n      return Promise.all(promises);\n    }\n    setup() {\n      let me = this;\n      self.addEventListener('install', event => {\n        self.skipWaiting();\n        event.waitUntil(me.precache());\n      });\n      self.addEventListener('activate', () => {\n        const version = '-v' + me.options.version;\n        caches.keys().then(cacheNames => {\n          return cacheNames.filter(cacheName => cacheName.indexOf(version) < 0);\n        }).then(cachesToDelete => {\n          return Promise.all(cachesToDelete.map(cacheToDelete => {\n            return caches.delete(cacheToDelete);\n          }));\n        }).then(() => self.clients.claim());\n      });\n      self.addEventListener('fetch', event => {\n        const request = event.request;\n        const otherReq = request.clone();\n        const oreq = request.clone();\n        if (request.method === 'GET') {\n          event.respondWith(me.respondWithPolicy(request).then(response => {\n            if (!response.ok && response.status > 0 && me.findRegex(oreq.url, me.options.fallbacks)) {\n              throw Error('response status ' + response.status);\n            }\n            return response;\n          }).catch(() => me.respondWithFallback(otherReq)));\n        }\n      });\n    }\n    setupPushNotification(defaultTitle = '', defaultOptions = { 'body': '' }) {\n      self.addEventListener('push', function (event) {\n        let data = {};\n        if (event.data) {\n          data = event.data.json();\n        }\n        console.log('[Sifrr Service Worker] Push received with data:', data);\n        const title = data.title || defaultTitle;\n        const options = data || defaultOptions;\n        event.waitUntil(self.registration.showNotification(title, options));\n      });\n    }\n    respondWithFallback(request) {\n      const fallback = this.requestFromURL(this.findRegex(request.url, this.options.fallbacks));\n      return this.responseFromCache(fallback, this.options.fallbackCacheName);\n    }\n    respondWithPolicy(request) {\n      const newreq = request.clone();\n      const config = this.findRegex(request.url, this.options.policies);\n      const policy = config.policy || 'NETWORK_FIRST';\n      const cacheName = config.cacheName || this.options.defaultCacheName;\n      let resp;\n      switch (policy) {\n        case 'NETWORK_ONLY':\n          resp = this.responseFromNetwork(newreq, cacheName, false);\n          break;\n        case ('CACHE_ONLY'):\n          resp = this.responseFromCache(newreq, cacheName).catch(() => this.responseFromNetwork(request, cacheName));\n          break;\n        case 'NETWORK_FIRST':\n          resp = this.responseFromNetwork(newreq, cacheName).catch(() => this.responseFromCache(request, cacheName));\n          break;\n        default:\n          resp = this.responseFromNetwork(newreq, cacheName).catch(() => this.responseFromCache(request, cacheName));\n          break;\n      }\n      return resp;\n    }\n    responseFromNetwork(request, cache, putInCache = true) {\n      return caches.open(cache + '-v' + this.options.version).then(cache => fetch(request).then(response => {\n        if (putInCache) cache.put(request, response.clone());\n        return response;\n      }));\n    }\n    responseFromCache(request, cache) {\n      return caches.open(cache + '-v' + this.options.version).then(cache => cache.match(request)).then(resp => {\n        if (resp) return resp;else throw 'Cache not found for ' + request.url;\n      });\n    }\n    requestFromURL(url, method = 'GET') {\n      return new Request(url, {\n        method: method\n      });\n    }\n    findRegex(url, policies) {\n      for (let [key, value] of Object.entries(policies)) {\n        const regex = new RegExp(key);\n        if (regex.test(url)) return value;\n      }\n      return policies['default'];\n    }\n  }\n  var sifrr_serviceworker = SW;\n\n  return sifrr_serviceworker;\n\n})));\n/*! (c) @aadityataparia */\n//# sourceMappingURL=sifrr.serviceworker.js.map\n"],"names":["sw","module","options","Object","assign","policies","default","this","defaultCacheName","fallbacks","urls","precacheUrls","fbs","me","promises","forEach","u","req","requestFromURL","push","responseFromNetwork","findRegex","cacheName","value","values","fallbackCacheName","Promise","all","addEventListener","event","skipWaiting","waitUntil","precache","version","keys","then","cacheNames","filter","indexOf","cachesToDelete","map","cacheToDelete","caches","delete","self","clients","claim","request","otherReq","clone","oreq","method","respondWith","respondWithPolicy","response","ok","status","url","Error","catch","respondWithFallback","defaultTitle","defaultOptions","body","data","json","log","title","registration","showNotification","fallback","responseFromCache","newreq","config","policy","resp","cache","putInCache","open","fetch","put","match","Request","key","entries","regex","RegExp","test","setup","setupPushNotification"],"mappings":"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"}