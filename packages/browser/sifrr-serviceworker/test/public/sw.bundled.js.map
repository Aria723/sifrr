{"version":3,"file":"sw.bundled.js","sources":["sw.js","../../dist/sifrr.serviceworker.js"],"sourcesContent":["const SW = require('../../dist/sifrr.serviceworker');\nconst sw = new SW({\n  version: 2,\n  fallbackCacheName: 'ffff',\n  defaultCacheName: 'dddd',\n  policies: {\n    cachefirst: {\n      policy: 'CACHE_FIRST'\n    },\n    networkfirst: {\n      policy: 'NETWORK_FIRST',\n      cacheName: 'bangbang'\n    },\n    networkonly: {\n      policy: 'NETWORK_ONLY'\n    },\n    server: {\n      policy: 'NETWORK_ONLY'\n    },\n    cacheonly: {\n      policy: 'CACHE_ONLY',\n      cacheName: 'bangbang2'\n    },\n    precache: {\n      policy: 'CACHE_ONLY',\n      cacheName: 'bangbang2'\n    },\n  },\n  fallbacks: {\n    networkonly: '/offline.html'\n  },\n  precacheUrls: ['/precache.js', '/cacheonly.js']\n});\n\nsw.setup();\nsw.setupPushNotification('default title', { body: 'default body' });\nmodule.exports = sw;\n","/*! Sifrr.Serviceworker v0.0.2-alpha - sifrr project */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Sifrr = global.Sifrr || {}, global.Sifrr.Serviceworker = factory());\n}(this, (function () { 'use strict';\n\n  class SW {\n    constructor(options) {\n      this.options = Object.assign({\n        version: 1,\n        fallbackCacheName: 'fallbacks',\n        defaultCacheName: 'default',\n        policies: {},\n        fallbacks: {},\n        precacheUrls: []\n      }, options);\n      this.options.policies.default = Object.assign(this.options.policies.default || {}, {\n        policy: 'NETWORK_FIRST',\n        cacheName: this.options.defaultCacheName\n      });\n    }\n    precache(urls = this.options.precacheUrls, fbs = this.options.fallbacks) {\n      const me = this;\n      let promises = [];\n      urls.forEach(u => {\n        let req = me.requestFromURL(u);\n        return promises.push(me.responseFromNetwork(req, me.findRegex(u, me.options.policies).cacheName || me.options.defaultCacheName));\n      });\n      for (let value of Object.values(fbs)) {\n        let req = this.requestFromURL(value);\n        promises.push(this.responseFromNetwork(req, this.options.fallbackCacheName));\n      }\n      return Promise.all(promises);\n    }\n    setup(skipWaiting = true) {\n      let me = this;\n      self.addEventListener('install', event => {\n        if (skipWaiting) self.skipWaiting();\n        event.waitUntil(me.precache());\n      });\n      self.addEventListener('activate', () => {\n        const version = '-v' + me.options.version;\n        caches.keys().then(cacheNames => {\n          return cacheNames.filter(cacheName => cacheName.indexOf(version) < 0);\n        }).then(cachesToDelete => {\n          return Promise.all(cachesToDelete.map(cacheToDelete => {\n            return caches.delete(cacheToDelete);\n          }));\n        }).then(() => self.clients.claim());\n      });\n      self.addEventListener('fetch', event => {\n        const request = event.request;\n        const otherReq = request.clone();\n        const oreq = request.clone();\n        if (request.method === 'GET') {\n          event.respondWith(me.respondWithPolicy(request).then(response => {\n            if (!response.ok && response.status > 0 && me.findRegex(oreq.url, me.options.fallbacks)) {\n              throw Error('response status ' + response.status);\n            }\n            return response;\n          }).catch(e => me.respondWithFallback(otherReq, e)));\n        }\n      });\n    }\n    setupPushNotification(defaultTitle = '', defaultOptions = {\n      body: ''\n    }, onNotificationClick) {\n      self.addEventListener('push', function (event) {\n        let data = {};\n        if (event.data) {\n          data = event.data.json();\n        }\n        const title = data.title || defaultTitle;\n        const options = Object.assign(defaultOptions, data);\n        event.waitUntil(self.registration.showNotification(title, options));\n      });\n      self.addEventListener('notificationclick', onNotificationClick);\n    }\n    respondWithFallback(request, error) {\n      const fallback = this.requestFromURL(this.findRegex(request.url, this.options.fallbacks));\n      if (fallback !== undefined) {\n        return this.responseFromCache(fallback, this.options.fallbackCacheName);\n      } else {\n        throw error;\n      }\n    }\n    respondWithPolicy(request) {\n      const newreq = request.clone();\n      const config = this.findRegex(request.url, this.options.policies);\n      const policy = config.policy || 'NETWORK_FIRST';\n      const cacheName = config.cacheName || this.options.defaultCacheName;\n      let resp;\n      switch (policy) {\n        case 'NETWORK_ONLY':\n          resp = this.responseFromNetwork(newreq, cacheName, false);\n          break;\n        case 'CACHE_FIRST':\n        case 'CACHE_ONLY':\n          resp = this.responseFromCache(newreq, cacheName).catch(() => this.responseFromNetwork(request, cacheName));\n          break;\n        case 'NETWORK_FIRST':\n          resp = this.responseFromNetwork(newreq, cacheName).catch(() => this.responseFromCache(request, cacheName));\n          break;\n        default:\n          resp = this.responseFromNetwork(newreq, cacheName).catch(() => this.responseFromCache(request, cacheName));\n          break;\n      }\n      return resp;\n    }\n    responseFromNetwork(request, cache, putInCache = true) {\n      return caches.open(cache + '-v' + this.options.version).then(cache => fetch(request).then(response => {\n        if (putInCache) cache.put(request, response.clone());\n        return response;\n      }));\n    }\n    responseFromCache(request, cache) {\n      return caches.open(cache + '-v' + this.options.version).then(cache => cache.match(request)).then(resp => {\n        if (resp) return resp;else throw 'Cache not found for ' + request.url;\n      });\n    }\n    requestFromURL(url, method = 'GET') {\n      return new Request(url, {\n        method: method\n      });\n    }\n    findRegex(url, policies) {\n      for (let [key, value] of Object.entries(policies)) {\n        const regex = new RegExp(key);\n        if (regex.test(url)) return value;\n      }\n      return policies['default'];\n    }\n  }\n  var sifrr_serviceworker = SW;\n\n  return sifrr_serviceworker;\n\n})));\n/*! (c) @aadityataparia */\n//# sourceMappingURL=sifrr.serviceworker.js.map\n"],"names":["sw","cacheName","options","forEach","this","req","addEventListener","self","event","version","cacheToDelete","request","Error","response","ok","status","me","findRegex","oreq","url","fallbacks","otherReq","data","title","onNotificationClick","[object Object]","responseFromCache","responseFromNetwork","caches","open","cache","then","fetch","method","Request","fallbackCacheName","defaultCacheName","policies","cachefirst","policy","networkfirst","networkonly","server","cacheonly","precache","precacheUrls","setup","setupPushNotification","body"],"mappings":"uRACA,MAAMA,EAAK,0LCQLC,wHAIYC,oCAGTC,EAASC,0DACRC,EAAJD,gCAGGC,wVAeAC,GAALC,KAAAA,cACEC,EAAMC,0BAGJF,KAAAD,+FAGuBI,iDAP3BH,OAAAA,OAAAA,WAaQI,oEAGFA,EAAAA,EAAJA,QACEH,EAAAA,gCAEUI,0DAERC,EAAAC,IAAAD,EAAAE,OAAA,GAAAC,EAAAC,UAAAC,EAAAC,IAAAH,EAAAd,QAAAkB,iBACOR,yBAA8BS,EALvCb,kJAeDc,EAAA,KAEKC,SACArB,8GASRK,KAAAD,qCAAAkB,GAEEC,oBAAYC,+dAwBGC,oBAAAhB,6JAWjBiB,OAAAC,KAAAC,EAAA,KAAA1B,KAAAF,QAAAO,SAAAsB,KAAAD,GAAAE,MAAArB,GAAAoB,KAAAlB,+IAakBoB,uEAInB,IAAAC,QAAAf,EAAA,kKDpIe,CAChBV,QAAS,EACT0B,kBAAmB,OACnBC,iBAAkB,OAClBC,SAAU,CACRC,WAAY,CACVC,OAAQ,eAEVC,aAAc,CACZD,OAAQ,gBACRtC,UAAW,YAEbwC,YAAa,CACXF,OAAQ,gBAEVG,OAAQ,CACNH,OAAQ,gBAEVI,UAAW,CACTJ,OAAQ,aACRtC,UAAW,aAEb2C,SAAU,CACRL,OAAQ,aACRtC,UAAW,cAGfmB,UAAW,CACTqB,YAAa,iBAEfI,aAAc,CAAC,eAAgB,0BAGjC7C,EAAG8C,QACH9C,EAAG+C,sBAAsB,gBAAiB,CAAEC,KAAM,iBACjChD"}