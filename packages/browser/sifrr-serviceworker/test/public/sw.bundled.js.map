{"version":3,"file":"sw.bundled.js","sources":["sw.js","../../dist/sifrr.serviceworker.js"],"sourcesContent":["const SW = require('../../dist/sifrr.serviceworker');\nmodule.exports = new SW({\n  version: 1,\n  fallbackCacheName: 'ffff',\n  defaultCacheName: 'dddd',\n  policies: {\n    'cachefirst': {\n      policy: 'CACHE_FIRST'\n    },\n    'networkfirst': {\n      policy: 'NETWORK_FIRST',\n      cacheName: 'bangbang'\n    },\n    'networkonly': {\n      policy: 'NETWORK_ONLY'\n    },\n    'cacheonly': {\n      policy: 'CACHE_ONLY',\n      cacheName: 'bangbang2'\n    },\n  },\n  fallbacks: {\n    'default': '/404.html'\n  },\n  precache_urls: ['/precache.js', './cacheonly.js']\n}).setup();\n","/*! Sifrr.Serviceworker v0.0.1-alpha - sifrr project - 2018/12/26 15:18:15 UTC */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Sifrr = global.Sifrr || {}, global.Sifrr.Serviceworker = factory());\n}(this, (function () { 'use strict';\n\n  class SW {\n    constructor(options) {\n      this.options = Object.assign({\n        version: 1,\n        fallbackCacheName: 'fallbacks',\n        defaultCacheName: 'default',\n        policies: {},\n        fallbacks: {},\n        precache_urls: []\n      }, options);\n      this.options.policies.default = Object.assign(this.options.policies.default || {}, {\n        policy: 'NETWORK_FIRST',\n        cacheName: this.options.defaultCacheName\n      });\n      this.options.fallbacks.default = this.options.fallbacks.default || '/offline.html';\n    }\n    precache(urls = this.options.precache_urls, fbs = this.options.fallbacks) {\n      const me = this;\n      let promises = [];\n      urls.forEach(u => {\n        let req = me.requestFromURL(u);\n        return promises.push(me.responseFromNetwork(req, me.findRegex(u, me.options.policies).cacheName || me.options.defaultCacheName));\n      });\n      for (let value of Object.values(fbs)) {\n        let req = this.requestFromURL(value);\n        promises.push(this.responseFromNetwork(req, this.options.fallbackCacheName));\n      }\n      return Promise.all(promises);\n    }\n    setup() {\n      let me = this;\n      self.addEventListener('install', event => {\n        self.skipWaiting();\n        event.waitUntil(me.precache());\n      });\n      self.addEventListener('activate', () => {\n        const version = '-v' + me.options.version;\n        caches.keys().then(cacheNames => {\n          return cacheNames.filter(cacheName => cacheName.indexOf(version) < 0);\n        }).then(cachesToDelete => {\n          return Promise.all(cachesToDelete.map(cacheToDelete => {\n            return caches.delete(cacheToDelete);\n          }));\n        }).then(() => self.clients.claim());\n      });\n      self.addEventListener('fetch', event => {\n        const request = event.request;\n        const otherReq = request.clone();\n        const oreq = request.clone();\n        if (request.method === 'GET') {\n          event.respondWith(me.respondWithPolicy(request).then(response => {\n            if (!response.ok && response.status > 0 && me.findRegex(oreq.url, me.options.fallbacks)) {\n              throw Error('response status ' + response.status);\n            }\n            return response;\n          }).catch(() => me.respondWithFallback(otherReq)));\n        }\n      });\n    }\n    respondWithFallback(request) {\n      const fallback = this.requestFromURL(this.findRegex(request.url, this.options.fallbacks));\n      return this.responseFromCache(fallback, this.options.fallbackCacheName);\n    }\n    respondWithPolicy(request) {\n      const newreq = request.clone();\n      const config = this.findRegex(request.url, this.options.policies);\n      const policy = config.policy || 'NETWORK_FIRST';\n      const cacheName = config.cacheName || this.options.defaultCacheName;\n      let resp;\n      switch (policy) {\n        case 'NETWORK_ONLY':\n          resp = this.responseFromNetwork(newreq, cacheName, false);\n          break;\n        case ('CACHE_ONLY'):\n          resp = this.responseFromCache(newreq, cacheName).catch(() => this.responseFromNetwork(request, cacheName));\n          break;\n        case 'NETWORK_FIRST':\n          resp = this.responseFromNetwork(newreq, cacheName).catch(() => this.responseFromCache(request, cacheName));\n          break;\n        default:\n          resp = this.responseFromNetwork(newreq, cacheName).catch(() => this.responseFromCache(request, cacheName));\n          break;\n      }\n      return resp;\n    }\n    responseFromNetwork(request, cache, putInCache = true) {\n      return caches.open(cache + '-v' + this.options.version).then(cache => fetch(request).then(response => {\n        if (putInCache) cache.put(request, response.clone());\n        return response;\n      }));\n    }\n    responseFromCache(request, cache) {\n      return caches.open(cache + '-v' + this.options.version).then(cache => cache.match(request)).then(resp => {\n        if (resp) return resp;else throw 'Cache not found for ' + request.url;\n      });\n    }\n    requestFromURL(url, method = 'GET') {\n      return new Request(url, {\n        method: method\n      });\n    }\n    findRegex(url, policies) {\n      for (let [key, value] of Object.entries(policies)) {\n        const regex = new RegExp(key);\n        if (regex.test(url)) return value;\n      }\n      return policies['default'];\n    }\n  }\n  var sifrr_serviceworker = SW;\n\n  return sifrr_serviceworker;\n\n})));\n/*! (c) @aadityataparia */\n//# sourceMappingURL=sifrr.serviceworker.js.map\n"],"names":["module","options","Object","assign","policies","default","this","defaultCacheName","fallbacks","urls","precache_urls","fbs","me","promises","forEach","u","req","requestFromURL","push","responseFromNetwork","findRegex","cacheName","value","values","fallbackCacheName","Promise","all","addEventListener","event","skipWaiting","waitUntil","precache","version","keys","then","cacheNames","filter","indexOf","cachesToDelete","map","cacheToDelete","caches","delete","self","clients","claim","request","otherReq","clone","oreq","method","respondWith","respondWithPolicy","response","ok","status","url","Error","catch","respondWithFallback","fallback","responseFromCache","newreq","config","policy","resp","cache","putInCache","open","fetch","put","match","Request","key","entries","regex","RegExp","test","setup"],"mappings":"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"}