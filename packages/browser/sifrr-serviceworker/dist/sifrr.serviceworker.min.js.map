{"version":3,"file":"sifrr.serviceworker.min.js","sources":["../src/sifrr.serviceworker.js"],"sourcesContent":["class SW {\n  constructor(options) {\n    this.options = Object.assign({\n      version: 1,\n      fallbackCacheName: 'fallbacks',\n      defaultCacheName: 'default',\n      policies: {},\n      fallbacks: {},\n      precacheUrls: []\n    }, options);\n    this.options.policies.default = Object.assign(this.options.policies.default || {}, {\n      policy: 'NETWORK_FIRST',\n      cacheName: this.options.defaultCacheName\n    });\n    this.options.fallbacks.default = this.options.fallbacks.default || '/offline.html';\n  }\n\n  precache(urls = this.options.precacheUrls, fbs = this.options.fallbacks) {\n    const me = this;\n    let promises = [];\n    urls.forEach(u => {\n      let req = me.requestFromURL(u);\n      return promises.push(me.responseFromNetwork(req, me.findRegex(u, me.options.policies).cacheName || me.options.defaultCacheName));\n    });\n    for (let value of Object.values(fbs)) {\n      let req = this.requestFromURL(value);\n      promises.push(this.responseFromNetwork(req, this.options.fallbackCacheName));\n    }\n    return Promise.all(promises);\n  }\n\n  setup() {\n    let me = this;\n    self.addEventListener('install', event => {\n      // replace old sw ASAP\n      self.skipWaiting();\n      event.waitUntil(me.precache());\n    });\n\n    self.addEventListener('activate', () => {\n      const version = '-v' + me.options.version;\n      // remove old version caches\n      caches.keys().then(cacheNames => {\n        return cacheNames.filter(cacheName => cacheName.indexOf(version) < 0);\n      }).then(cachesToDelete => {\n        return Promise.all(cachesToDelete.map(cacheToDelete => {\n          return caches.delete(cacheToDelete);\n        }));\n      }).then(() => self.clients.claim());\n    });\n\n    self.addEventListener('fetch', event => {\n      const request = event.request;\n      const otherReq = request.clone();\n      const oreq = request.clone();\n      if (request.method === 'GET') {\n        event.respondWith(me.respondWithPolicy(request).then(response => {\n          if (!response.ok && response.status > 0 && me.findRegex(oreq.url, me.options.fallbacks)) {\n            throw Error('response status ' + response.status);\n          }\n          return response;\n        }).catch(() => me.respondWithFallback(otherReq)));\n      }\n    });\n  }\n\n  setupPushNotification(defaultTitle = '', defaultOptions = { 'body': '' }, onNotificationClick) {\n    self.addEventListener('push', function(event) {\n      let data = {};\n      if (event.data) {\n        data = event.data.json();\n      }\n\n      const title = data.title || defaultTitle;\n      const options = Object.assign(defaultOptions, data);\n\n      event.waitUntil(self.registration.showNotification(title, options));\n    });\n\n    self.addEventListener('notificationclick', onNotificationClick);\n  }\n\n  respondWithFallback(request) {\n    const fallback = this.requestFromURL(this.findRegex(request.url, this.options.fallbacks));\n    return this.responseFromCache(fallback, this.options.fallbackCacheName);\n  }\n\n  respondWithPolicy(request) {\n    const newreq = request.clone();\n    const config = this.findRegex(request.url, this.options.policies);\n    const policy = config.policy || 'NETWORK_FIRST';\n    const cacheName = config.cacheName || this.options.defaultCacheName;\n\n    let resp;\n    switch (policy) {\n    case 'NETWORK_ONLY':\n      resp = this.responseFromNetwork(newreq, cacheName, false);\n      break;\n    case 'CACHE_FIRST', 'CACHE_ONLY':\n      resp = this.responseFromCache(newreq, cacheName)\n        .catch(() => this.responseFromNetwork(request, cacheName));\n      break;\n    case 'NETWORK_FIRST':\n      resp = this.responseFromNetwork(newreq, cacheName)\n        .catch(() => this.responseFromCache(request, cacheName));\n      break;\n    default:\n      resp = this.responseFromNetwork(newreq, cacheName)\n        .catch(() => this.responseFromCache(request, cacheName));\n      break;\n    }\n    return resp;\n  }\n\n  responseFromNetwork(request, cache, putInCache = true) {\n    return caches.open(cache + '-v' + this.options.version).then(cache => fetch(request).then(response => {\n      if (putInCache) cache.put(request, response.clone());\n      return response;\n    }));\n  }\n\n  responseFromCache(request, cache) {\n    return caches.open(cache + '-v' + this.options.version).then(cache => cache.match(request)).then(resp => {\n      if (resp) return resp;\n      else throw 'Cache not found for ' + request.url;\n    });\n  }\n\n  requestFromURL(url, method = 'GET') {\n    return new Request(url, {\n      method: method\n    });\n  }\n\n  findRegex(url, policies) {\n    for (let [key, value] of Object.entries(policies)) {\n      const regex = new RegExp(key);\n      if (regex.test(url)) return value;\n    }\n    return policies['default'];\n  }\n}\n\nmodule.exports = SW;\n"],"names":["options","Object","assign","policies","default","this","defaultCacheName","fallbacks","urls","precacheUrls","fbs","me","promises","forEach","u","req","requestFromURL","push","responseFromNetwork","findRegex","cacheName","value","values","fallbackCacheName","Promise","all","addEventListener","event","skipWaiting","waitUntil","precache","version","keys","then","cacheNames","filter","indexOf","cachesToDelete","map","cacheToDelete","caches","delete","self","clients","claim","request","otherReq","clone","oreq","method","respondWith","respondWithPolicy","response","ok","status","url","Error","catch","respondWithFallback","defaultTitle","defaultOptions","body","onNotificationClick","data","json","title","registration","showNotification","fallback","responseFromCache","newreq","config","policy","resp","cache","putInCache","open","fetch","put","match","Request","key","entries","RegExp","test"],"mappings":"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"}