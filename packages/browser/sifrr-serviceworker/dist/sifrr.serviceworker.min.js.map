{"version":3,"file":"sifrr.serviceworker.min.js","sources":["../src/sifrr.serviceworker.js"],"sourcesContent":["class SW {\n  constructor(options) {\n    this.options = Object.assign({\n      version: 1,\n      fallbackCacheName: 'fallbacks',\n      defaultCacheName: 'default',\n      policies: {},\n      fallbacks: {},\n      precacheUrls: []\n    }, options);\n    this.options.policies.default = Object.assign(this.options.policies.default || {}, {\n      policy: 'NETWORK_FIRST',\n      cacheName: this.options.defaultCacheName\n    });\n  }\n\n  precache(urls = this.options.precacheUrls, fbs = this.options.fallbacks) {\n    const me = this;\n    let promises = [];\n    urls.forEach(u => {\n      let req = me.requestFromURL(u);\n      return promises.push(me.responseFromNetwork(req, me.findRegex(u, me.options.policies).cacheName));\n    });\n    for (let value of Object.values(fbs)) {\n      let req = this.requestFromURL(value);\n      promises.push(this.responseFromNetwork(req, this.options.fallbackCacheName));\n    }\n    return Promise.all(promises);\n  }\n\n  setup(skipWaiting = true) {\n    let me = this;\n    self.addEventListener('install', event => {\n      // replace old sw ASAP\n      if (skipWaiting) self.skipWaiting();\n      event.waitUntil(me.precache());\n    });\n\n    self.addEventListener('activate', () => {\n      const version = '-v' + me.options.version;\n      // remove old version caches\n      caches.keys().then(cacheNames => {\n        return cacheNames.filter(cacheName => cacheName.indexOf(version) < 0);\n      }).then(cachesToDelete => {\n        return Promise.all(cachesToDelete.map(cacheToDelete => {\n          return caches.delete(cacheToDelete);\n        }));\n      }).then(() => self.clients.claim());\n    });\n\n    self.addEventListener('fetch', event => {\n      const request = event.request;\n      const otherReq = request.clone();\n      const oreq = request.clone();\n      if (request.method === 'GET') {\n        event.respondWith(me.respondWithPolicy(request).then(response => {\n          if (!response.ok && response.status > 0 && me.findRegex(oreq.url, me.options.fallbacks)) {\n            throw Error('response status ' + response.status);\n          }\n          return response;\n        }).catch((e) => me.respondWithFallback(otherReq, e)));\n      }\n    });\n  }\n\n  setupPushNotification(defaultTitle = '', defaultOptions = { body: '' }, onNotificationClick) {\n    self.addEventListener('push', function(event) {\n      console.log(event);\n\n      let data = {};\n      if (event.data) {\n        data = event.data.json();\n      }\n\n      const title = data.title || defaultTitle;\n      const options = Object.assign(defaultOptions, data);\n      for (let k in options) {\n        if (k.indexOf('on') === 0) options[k] = new Function(options[k]);\n        console.log(k, options[k]);\n      }\n\n      event.waitUntil(self.registration.showNotification(title, options));\n    });\n\n    self.addEventListener('notificationclick', onNotificationClick);\n  }\n\n  respondWithFallback(request, error) {\n    const fallback = this.requestFromURL(this.findRegex(request.url, this.options.fallbacks));\n    if (fallback !== undefined) {\n      return this.responseFromCache(fallback, this.options.fallbackCacheName);\n    } else {\n      throw error;\n    }\n  }\n\n  respondWithPolicy(request) {\n    const req1 = request.clone();\n    const req2 = request.clone();\n    const config = this.findRegex(request.url, this.options.policies);\n    const policy = config.policy;\n    const cacheName = config.cacheName || this.options.defaultCacheName;\n\n    let resp;\n    switch (policy) {\n    case 'NETWORK_ONLY':\n      resp = this.responseFromNetwork(req1, cacheName, false);\n      break;\n    case 'CACHE_FIRST':\n    case 'CACHE_ONLY':\n      resp = this.responseFromCache(req1, cacheName)\n        .catch(() => this.responseFromNetwork(request, cacheName));\n      break;\n    case 'CACHE_AND_UPDATE':\n      resp = this.responseFromCache(req1, cacheName)\n        .catch(() => this.responseFromNetwork(request, cacheName));\n      this.responseFromNetwork(req2, cacheName);\n      break;\n    default:\n      resp = this.responseFromNetwork(req1, cacheName)\n        .catch(() => this.responseFromCache(request, cacheName));\n      break;\n    }\n    return resp;\n  }\n\n  responseFromNetwork(request, cache, putInCache = true) {\n    return caches.open(cache + '-v' + this.options.version).then(cache => fetch(request).then(response => {\n      if (putInCache) cache.put(request, response.clone());\n      return response;\n    }));\n  }\n\n  responseFromCache(request, cache) {\n    return caches.open(cache + '-v' + this.options.version).then(cache => cache.match(request)).then(resp => {\n      if (resp) return resp;\n      else throw 'Cache not found for ' + request.url;\n    });\n  }\n\n  requestFromURL(url, method = 'GET') {\n    return new Request(url, {\n      method: method\n    });\n  }\n\n  findRegex(url, policies) {\n    for (let [key, value] of Object.entries(policies)) {\n      const regex = new RegExp(key);\n      if (regex.test(url)) return value;\n    }\n    return policies['default'];\n  }\n}\n\nmodule.exports = SW;\n"],"names":["constructor","options","Object","assign","version","fallbackCacheName","defaultCacheName","policies","fallbacks","precacheUrls","default","this","policy","cacheName","precache","urls","fbs","me","promises","forEach","u","req","requestFromURL","push","responseFromNetwork","findRegex","value","values","Promise","all","setup","skipWaiting","self","addEventListener","event","waitUntil","caches","keys","then","cacheNames","filter","indexOf","cachesToDelete","map","cacheToDelete","delete","clients","claim","request","otherReq","clone","oreq","method","respondWith","respondWithPolicy","response","ok","status","url","Error","catch","e","respondWithFallback","setupPushNotification","defaultTitle","defaultOptions","body","onNotificationClick","console","log","data","json","title","k","Function","registration","showNotification","error","fallback","undefined","responseFromCache","req1","req2","config","resp","cache","putInCache","open","fetch","put","match","Request","key","entries","RegExp","test"],"mappings":"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"}