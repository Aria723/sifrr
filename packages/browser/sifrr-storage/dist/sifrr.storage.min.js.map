{"version":3,"file":"sifrr.storage.min.js","sources":["../src/utils/json.js","../src/storages/storage.js","../src/storages/indexeddb.js","../src/storages/websql.js","../src/storages/localstorage.js","../src/storages/cookies.js","../src/storages/jsonstorage.js","../src/storages.js","../src/sifrr.storage.js"],"sourcesContent":["class Json {\n  static parse(data) {\n    let ans = {};\n    if (typeof data == 'string') {\n      try {\n        ans = JSON.parse(data);\n      } catch(e) {\n        return data;\n      }\n      return this.parse(ans);\n    } else if (Array.isArray(data)) {\n      ans = [];\n      data.forEach((v, i) => {\n        ans[i] = this.parse(v);\n      });\n    } else if (typeof data == 'object') {\n      for (const k in data) {\n        ans[k] = this.parse(data[k]);\n      }\n    } else {\n      return data;\n    }\n    return ans;\n  }\n\n  static stringify(data) {\n    if (typeof data == 'string') {\n      return data;\n    } else {\n      return JSON.stringify(data);\n    }\n  }\n}\n\nmodule.exports = Json;\n","const JsonExt = require('../utils/json');\n\nclass Storage {\n  constructor(options) {\n    this._options = options;\n  }\n\n  _parseKeyValue(key, value) {\n    let jsonConstructor = {}.constructor;\n    if (typeof value == 'undefined') {\n      if (Array.isArray(key)) {\n        return key;\n      } else if (typeof key == 'string') {\n        return [key];\n      } else if (key.constructor === jsonConstructor) {\n        return key;\n      } {\n        throw Error('Invalid Key');\n      }\n    } else if (typeof key == 'string') {\n      let ans = {};\n      ans[key] = value;\n      return ans;\n    } else {\n      throw Error('Invalid Key');\n    }\n  }\n\n  _select(keys) {\n    return this.data().then((data) => {\n      let ans = {};\n      keys.forEach((key) => ans[key] = data[key]);\n      return ans;\n    });\n  }\n\n  _upsert(data) {\n    let table = this.table;\n    for (let key in data) {\n      table[key] = data[key];\n    }\n    this.table = table;\n  }\n\n  _delete(keys) {\n    let table = this.table;\n    keys.forEach((key) => delete table[key]);\n    this.table = table;\n  }\n\n  _clear() {\n    this.table = {};\n  }\n\n  _isEqual(options, type) {\n    if (this.tableName == options.name + options.version && this.type == type) { return true; }\n    else { return false; }\n  }\n\n  get tableName() {\n    return this.name + this.version;\n  }\n\n  get name() {\n    return this._options.name;\n  }\n\n  get version() {\n    return this._options.version;\n  }\n\n  get description() {\n    return this._options.description;\n  }\n\n  get type() {\n    return this.constructor.type;\n  }\n\n  isSupported() {\n    if (typeof window == 'undefined' || typeof document == 'undefined') { return true; }\n    else if (window && typeof this.store != 'undefined') { return true; }\n    else { return false; }\n  }\n\n  all() {\n    return this.data();\n  }\n\n  data() {\n    return Promise.resolve(this._parsedData());\n  }\n\n  select(key) {\n    return Promise.resolve(this._select(this._parseKeyValue(key)));\n  }\n\n  insert(key, value) {\n    return Promise.resolve(this._upsert(this._parseKeyValue(key, value)));\n  }\n\n  update(key, value) {\n    return Promise.resolve(this._upsert(this._parseKeyValue(key, value)));\n  }\n\n  upsert(key, value) {\n    return Promise.resolve(this._upsert(this._parseKeyValue(key, value)));\n  }\n\n  delete(key) {\n    return Promise.resolve(this._delete(this._parseKeyValue(key)));\n  }\n\n  deleteAll() {\n    return Promise.resolve(this._clear());\n  }\n\n  clear() {\n    return Promise.resolve(this._clear());\n  }\n\n  static stringify(data) {\n    return JsonExt.stringify(data);\n  }\n\n  static parse(data) {\n    return JsonExt.parse(data);\n  }\n}\n\nmodule.exports = Storage;\n","const Storage = require('./storage');\n\nclass IndexedDB extends Storage {\n  constructor(options) {\n    super(options);\n  }\n\n  _parsedData() {\n    return this._tx('readonly', 'getAll').then((result) => this.parse(result));\n  }\n\n  _select(keys) {\n    let ans = {};\n    let promises = [];\n    keys.forEach((key) => promises.push(this._tx('readonly', 'get', key).then((r) => ans[key] = this.parse(r))));\n    return Promise.all(promises).then(() => ans);\n  }\n\n  _upsert(data) {\n    let promises = [];\n    for (let key in data) {\n      let promise = this._tx('readonly', 'get', key).then((oldResult) => {\n        if (oldResult && oldResult.key == key) {\n          return this._tx('readwrite', 'put', { key: key, value: data[key] });\n        } else {\n          return this._tx('readwrite', 'add', { key: key, value: data[key] });\n        }\n      });\n      promises.push(promise);\n    }\n    return Promise.all(promises);\n  }\n\n  _delete(keys) {\n    let promises = [];\n    keys.forEach((key) => promises.push(this._tx('readwrite', 'delete', key)));\n    return Promise.all(promises);\n  }\n\n  _clear() {\n    return this._tx('readwrite', 'clear');\n  }\n\n  _tx(scope, fn, params) {\n    let me = this;\n    return this.createStore(me.tableName).then((db) => {\n      return new Promise((resolve, reject) => {\n        let tx = db.transaction(me.tableName, scope).objectStore(me.tableName);\n        let request = tx[fn].call(tx, params);\n        request.onsuccess = (event) =>  resolve(event.target.result);\n        request.onerror = (event) => reject(event.error);\n      });\n    });\n  }\n\n  get store() {\n    return window.indexedDB;\n  }\n\n  createStore(table) {\n    return new Promise((resolve, reject) => {\n      const request = this.store.open(table, 1);\n      request.onupgradeneeded = (event) => {\n        let db = event.target.result;\n        db.createObjectStore(table, { keyPath: 'key' });\n      };\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  parse(data) {\n    let ans = {};\n    if (Array.isArray(data)) {\n      data.forEach((row) => {\n        ans[row.key] = row.value;\n      });\n    } else if (data && data.value) {\n      return data.value;\n    } else {\n      return undefined;\n    }\n    return ans;\n  }\n\n  static get type() {\n    return 'indexeddb';\n  }\n}\n\nmodule.exports = IndexedDB;\n","const Storage = require('./storage');\n\nclass WebSQL extends Storage {\n  constructor(options) {\n    super(options);\n    this.createStore();\n  }\n\n  _parsedData() {\n    let me = this;\n    return new Promise((resolve) => {\n      this.store.transaction(function (tx) {\n        tx.executeSql(`SELECT * FROM ${me.tableName}`, [], (txn, results) => {\n          resolve(me.parse(results));\n        });\n      });\n    });\n  }\n\n  _select(keys) {\n    let me = this;\n    let q = keys.map(() => '?').join(', ');\n    // Need to give array for ? values in executeSql's 2nd argument\n    return this.execSql(`SELECT key, value FROM ${me.tableName} WHERE key in (${q})`, keys);\n  }\n\n  _upsert(data) {\n    let table = this.tableName;\n    this.store.transaction((tx) => {\n      for (let key in data) {\n        tx.executeSql(`INSERT OR IGNORE INTO ${table}(key, value) VALUES (?, ?)`, [key, data[key]]);\n        tx.executeSql(`UPDATE ${table} SET value = ? WHERE key = ?`, [this.constructor.stringify(data[key]), key]);\n      }\n    });\n  }\n\n  _delete(keys) {\n    let table = this.tableName;\n    let q = keys.map(() => '?').join(', ');\n    return this.execSql(`DELETE FROM ${table} WHERE key in (${q})`, keys);\n  }\n\n  _clear() {\n    let table = this.tableName;\n    return this.execSql(`DELETE FROM ${table}`);\n  }\n\n  get store() {\n    if (typeof window !== 'undefined') {\n      return window.openDatabase('bs', 1, this._options.description, this._options.size);\n    } else {\n      return true;\n    }\n  }\n\n  createStore() {\n    let table = this.tableName;\n    if (typeof window == 'undefined') return;\n    return this.execSql(`CREATE TABLE IF NOT EXISTS ${table} (key unique, value)`);\n  }\n\n  execSql(query, args = []) {\n    let me = this;\n    return new Promise((resolve) => {\n      me.store.transaction(function (tx) {\n        tx.executeSql(query, args, (txn, results) => {\n          resolve(me.parse(results));\n        });\n      });\n    });\n  }\n\n  parse(results) {\n    let ans = {};\n    let len = results.rows.length, i;\n    for (i = 0; i < len; i++) {\n      ans[results.rows.item(i).key] = this.constructor.parse(results.rows.item(i).value);\n    }\n    return ans;\n  }\n\n  static get type() {\n    return 'websql';\n  }\n}\n\nmodule.exports = WebSQL;\n","const Storage = require('./storage');\n\nclass LocalStorage extends Storage {\n  constructor(options) {\n    super(options);\n  }\n\n  _parsedData() {\n    return this.table;\n  }\n\n  get table() {\n    return this.constructor.parse(this.store.getItem(this.tableName));\n  }\n\n  set table(value) {\n    this.store.setItem(this.tableName, this.constructor.stringify(value));\n  }\n\n  get store() {\n    return window.localStorage;\n  }\n\n  static get type() {\n    return 'localstorage';\n  }\n}\n\nmodule.exports = LocalStorage;\n","const Storage = require('./storage');\n\nclass Cookies extends Storage {\n  constructor(options) {\n    super(options);\n  }\n\n  _parsedData() {\n    return this.table;\n  }\n\n  get table() {\n    let result = this.store, ans = {};\n    result.split('; ').forEach((value) => {\n      let [k, v] = value.split('=');\n      if (v) ans[k] = this.constructor.parse(v);\n    });\n    return ans[this.tableName] || {};\n  }\n\n  set table(value) {\n    document.cookie = `${this.tableName}=${Storage.stringify(value)}; path=/`;\n  }\n\n  get store() {\n    return document.cookie;\n  }\n\n  static get type() {\n    return 'cookies';\n  }\n}\n\nmodule.exports = Cookies;\n","const Storage = require('./storage');\n\nclass JsonStorage extends Storage {\n  constructor(options, data = {}) {\n    super(options);\n    this._upsert(this.constructor.parse(data));\n  }\n\n  _parsedData() {\n    return this._table;\n  }\n\n  get store() {\n    return this._table;\n  }\n\n  get table() {\n    return this._table || {};\n  }\n\n  set table(value) {\n    this._table = value;\n  }\n\n  static get type() {\n    return 'jsonstorage';\n  }\n}\n\nmodule.exports = JsonStorage;\n","const IndexedDB = require('./storages/indexeddb');\nconst WebSQL = require('./storages/websql');\nconst LocalStorage = require('./storages/localstorage');\nconst Cookies = require('./storages/cookies');\nconst JsonStorage = require('./storages/jsonstorage');\n\nlet storages = {};\nstorages[IndexedDB.type] = IndexedDB;\nstorages[WebSQL.type] = WebSQL;\nstorages[LocalStorage.type] = LocalStorage;\nstorages[Cookies.type] = Cookies;\nstorages[JsonStorage.type] = JsonStorage;\n\nmodule.exports = storages;\n","const storages = require('./storages');\nconst JsonStorage = require('./storages/jsonstorage');\n\nclass SifrrStorage {\n  constructor(options) {\n    if (typeof options == 'string') options = { priority: [options] }; else options = options || {};\n    this._options = Object.assign(this.constructor.defaultOptions, options);\n    return this.storage;\n  }\n\n  get storage() {\n    let storage = this.supportedStore();\n    if (typeof storage == 'undefined') throw new Error('No available storage supported in this browser');\n    let matchingInstance = this.constructor._matchingInstance(this._options, storage.type);\n    if (matchingInstance) { return matchingInstance; }\n    else {\n      let storageInstance = new storage(this._options);\n      this.constructor._add(storageInstance);\n      return storageInstance;\n    }\n  }\n\n  get priority() {\n    return this._options.priority.concat(['indexeddb', 'websql', 'localstorage', 'cookies', 'jsonstorage']);\n  }\n\n  supportedStore() {\n    for (let i = 0; i < this.priority.length; i++) {\n      let store = this.constructor.availableStores[this.priority[i]];\n      if (store && new store(this._options).isSupported()) return store;\n    }\n  }\n\n  static _matchingInstance(options, type) {\n    let allInstances = this.all, i;\n    let length = allInstances.length;\n    for (i = 0; i < length; i++) {\n      if (allInstances[i]._isEqual(options, type)) return allInstances[i];\n    }\n    return false;\n  }\n\n  static _add(instance) {\n    this._all = this._all || [];\n    this._all.push(instance);\n  }\n\n  static get availableStores() {\n    return storages;\n  }\n\n  static get defaultOptions() {\n    return {\n      priority: [],\n      name: 'SifrrStorage',\n      version: 1,\n      description: 'Sifrr Storage',\n      size: 5 * 1024 * 1024\n    };\n  }\n\n  static get all() {\n    return this._all || [];\n  }\n\n  static json(data) {\n    return new JsonStorage({}, data);\n  }\n}\n\nmodule.exports = SifrrStorage;\n"],"names":["data","ans","JSON","parse","e","this","Array","isArray","forEach","v","i","k","stringify","constructor","options","_options","_parseKeyValue","key","value","jsonConstructor","Error","_select","keys","then","_upsert","table","_delete","_clear","_isEqual","type","tableName","name","version","description","isSupported","window","document","store","all","Promise","resolve","_parsedData","select","insert","update","upsert","delete","deleteAll","clear","JsonExt","Storage","_tx","result","promises","push","r","promise","oldResult","scope","fn","params","me","createStore","db","reject","tx","transaction","objectStore","request","call","onsuccess","event","target","onerror","error","indexedDB","open","onupgradeneeded","createObjectStore","keyPath","row","executeSql","txn","results","q","map","join","execSql","openDatabase","size","query","args","len","rows","length","item","getItem","setItem","localStorage","split","cookie","_table","storages","IndexedDB","WebSQL","LocalStorage","Cookies","JsonStorage","priority","Object","assign","defaultOptions","storage","supportedStore","matchingInstance","_matchingInstance","storageInstance","_add","concat","availableStores","allInstances","instance","_all"],"mappings":"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"}