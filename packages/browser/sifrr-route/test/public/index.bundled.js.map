{"version":3,"file":"index.bundled.js","sources":["../../../sifrr-dom/dist/sifrr.dom.js","index.js"],"sourcesContent":["/*! Sifrr.Dom v0.0.1-alpha2 - sifrr project */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Sifrr = global.Sifrr || {}, global.Sifrr.Dom = factory());\n}(this, (function () { 'use strict';\n\n  const URLExt = {\n    absolute: (base, relative) => {\n      let stack = base.split('/'),\n          parts = relative.split('/');\n      stack.pop();\n      for (let i = 0; i < parts.length; i++) {\n        if (parts[i] == '.') continue;\n        if (parts[i] == '..') stack.pop();else stack.push(parts[i]);\n      }\n      return stack.join('/');\n    },\n    getRoutes: url => {\n      if (url[0] != '/') {\n        url = '/' + url;\n      }\n      let qIndex = url.indexOf('?');\n      if (qIndex != -1) {\n        url = url.substring(0, qIndex);\n      }\n      return url.split('/');\n    }\n  };\n  var url = URLExt;\n\n  const Json = {\n    parse: data => {\n      let ans = {};\n      if (typeof data == 'string') {\n        try {\n          ans = JSON.parse(data);\n        } catch (e) {\n          return data;\n        }\n        return Json.parse(ans);\n      } else if (Array.isArray(data)) {\n        ans = [];\n        data.forEach((v, i) => {\n          ans[i] = Json.parse(v);\n        });\n      } else if (typeof data == 'object') {\n        for (const k in data) {\n          ans[k] = Json.parse(data[k]);\n        }\n      } else {\n        return data;\n      }\n      return ans;\n    },\n    stringify: data => {\n      if (typeof data == 'string') {\n        return data;\n      } else {\n        return JSON.stringify(data);\n      }\n    },\n    shallowEqual: (a, b) => {\n      for (let key in a) {\n        if (!(key in b) || a[key] != b[key]) {\n          return false;\n        }\n      }\n      for (let key in b) {\n        if (!(key in a) || a[key] != b[key]) {\n          return false;\n        }\n      }\n      return true;\n    },\n    deepClone: json => {\n      if (Array.isArray(json)) return json.map(i => Json.deepClone(i));\n      if (typeof json !== 'object' || json === null) return json;\n      let clone = {};\n      for (let key in json) {\n        clone[key] = Json.deepClone(json[key]);\n      }\n      return clone;\n    }\n  };\n  var json = Json;\n\n  function updateAttribute(element, name, newValue) {\n    if (name === 'class') {\n      const fromValue = element.className;\n      if (fromValue != newValue) {\n        if (newValue == 'null' || newValue == 'undefined' || newValue == 'false' || !newValue) {\n          element.className = '';\n        } else {\n          element.className = newValue;\n        }\n      }\n    } else {\n      const fromValue = element.getAttribute(name);\n      if (fromValue != newValue) {\n        if (newValue == 'null' || newValue == 'undefined' || newValue == 'false' || !newValue) {\n          if (fromValue) element.removeAttribute(name);\n        } else {\n          element.setAttribute(name, newValue);\n        }\n      }\n      if ((element.nodeName == 'SELECT' || element.nodeName == 'INPUT') && name == 'value') element.value = newValue;\n    }\n  }\n  var update = {\n    updateAttribute\n  };\n\n  var constants = {\n    SIFRR_NODE: window.document.createElement('sifrr-node'),\n    TEMPLATE: window.document.createElement('template'),\n    TEXT_NODE: 3,\n    COMMENT_NODE: 8,\n    ELEMENT_NODE: 1\n  };\n\n  const {\n    updateAttribute: updateAttribute$1\n  } = update;\n  const {\n    shallowEqual\n  } = json;\n  const {\n    TEXT_NODE,\n    COMMENT_NODE\n  } = constants;\n  function makeChildrenEqual(parent, newChildren) {\n    const oldL = parent.childNodes.length,\n          newL = newChildren.length;\n    if (oldL > newL) {\n      let i = oldL;\n      while (i > newL) {\n        parent.removeChild(parent.lastChild);\n        i--;\n      }\n    } else if (oldL < newL) {\n      let i = oldL;\n      while (i < newL) {\n        parent.appendChild(newChildren[i]);\n        i++;\n      }\n    }\n    const l = Math.min(newL, oldL);\n    for (let i = 0, item, head = parent.firstChild; i < l; i++) {\n      item = newChildren[i];\n      head = makeEqual(head, item).nextSibling;\n    }\n  }\n  function makeEqual(oldNode, newNode) {\n    if (newNode === null) return oldNode;\n    if (newNode.type === 'stateChange') {\n      if (!shallowEqual(oldNode.state, newNode.state)) {\n        oldNode.state = newNode.state;\n      }\n      return oldNode;\n    }\n    if (oldNode.nodeName !== newNode.nodeName) {\n      oldNode.replaceWith(newNode);\n      return newNode;\n    }\n    if (oldNode.nodeType === TEXT_NODE || oldNode.nodeType === COMMENT_NODE) {\n      if (oldNode.data !== newNode.data) oldNode.data = newNode.data;\n      return oldNode;\n    }\n    if (newNode.state) oldNode.state = newNode.state;\n    let oldAttrs = oldNode.attributes,\n        newAttrs = newNode.attributes,\n        attr;\n    for (let i = newAttrs.length - 1; i >= 0; --i) {\n      updateAttribute$1(oldNode, newAttrs[i].name, newAttrs[i].value);\n    }\n    for (let j = oldAttrs.length - 1; j >= 0; --j) {\n      attr = oldAttrs[j];\n      if (!newNode.hasAttribute(attr.name) && attr.specified !== false) oldNode.removeAttribute(attr.name);\n    }\n    makeChildrenEqual(oldNode, newNode.childNodes);\n    return oldNode;\n  }\n  var makeequal = {\n    makeEqual,\n    makeChildrenEqual\n  };\n\n  const TREE_WALKER = window.document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, false);\n  TREE_WALKER.roll = function (n, filter = false) {\n    let node = this.currentNode;\n    while (--n) {\n      if (filter && filter(node)) {\n        node = TREE_WALKER.nextSibling() || TREE_WALKER.parentNode();\n      } else node = TREE_WALKER.nextNode();\n    }\n    return node;\n  };\n  function collect(element, stateMap = element.stateMap, filter) {\n    const refs = [];\n    TREE_WALKER.currentNode = element;\n    stateMap.map(x => refs.push(TREE_WALKER.roll(x.idx, filter)));\n    return refs;\n  }\n  class Ref {\n    constructor(idx, ref) {\n      this.idx = idx;\n      this.ref = ref;\n    }\n  }\n  function create(node, fxn, filter = false) {\n    let indices = [],\n        ref,\n        idx = 0;\n    TREE_WALKER.currentNode = node;\n    while (node) {\n      if (ref = fxn(node)) {\n        indices.push(new Ref(idx + 1, ref));\n        idx = 1;\n      } else {\n        idx++;\n      }\n      if (filter && filter(node)) {\n        node = TREE_WALKER.nextSibling() || TREE_WALKER.parentNode();\n      } else node = TREE_WALKER.nextNode();\n    }\n    return indices;\n  }\n  var ref = {\n    walker: TREE_WALKER,\n    collect,\n    create,\n    Ref\n  };\n\n  const {\n    makeChildrenEqual: makeChildrenEqual$1\n  } = makeequal;\n  const {\n    updateAttribute: updateAttribute$2\n  } = update;\n  const {\n    collect: collect$1,\n    create: create$1\n  } = ref;\n  const {\n    TEMPLATE,\n    TEXT_NODE: TEXT_NODE$1,\n    COMMENT_NODE: COMMENT_NODE$1,\n    ELEMENT_NODE\n  } = constants;\n  function isHtml(el) {\n    return el.dataset && el.dataset.sifrrHtml == 'true' || el.contentEditable == 'true' || el.nodeName == 'TEXTAREA' || el.nodeName == 'STYLE' || el.dataset && el.dataset.sifrrRepeat;\n  }\n  function creator(el) {\n    if (el.nodeType === TEXT_NODE$1 || el.nodeType === COMMENT_NODE$1) {\n      const x = el.nodeValue;\n      if (x.indexOf('${') > -1) return {\n        html: false,\n        text: x.trim()\n      };\n    } else if (el.nodeType === ELEMENT_NODE) {\n      const sm = {};\n      if (isHtml(el)) {\n        const innerHTML = el.innerHTML;\n        if (innerHTML.indexOf('${') >= 0) {\n          sm.html = true;\n          sm.text = innerHTML.replace(/<!--(.*)-->/g, '$1');\n        }\n      }\n      const attrs = el.attributes || [],\n            l = attrs.length;\n      const attrStateMap = {\n        events: {}\n      };\n      for (let i = 0; i < l; i++) {\n        const attribute = attrs[i];\n        if (attribute.name[0] === '$') {\n          attrStateMap.events[attribute.name] = attribute.value;\n        } else if (attribute.value.indexOf('${') >= 0) {\n          attrStateMap[attribute.name] = attribute.value;\n        }\n      }\n      if (Object.keys(attrStateMap).length > 0) sm.attributes = attrStateMap;\n      if (Object.keys(sm).length > 0) return sm;\n    }\n    return 0;\n  }\n  const Parser = {\n    collectRefs: (el, stateMap) => collect$1(el, stateMap, isHtml),\n    createStateMap: element => create$1(element, creator, isHtml),\n    update: element => {\n      if (!element._refs) {\n        return false;\n      }\n      const l = element._refs.length;\n      for (let i = 0; i < l; i++) {\n        const data = element.constructor.stateMap[i].ref;\n        const dom = element._refs[i];\n        if (data.attributes) {\n          for (let key in data.attributes) {\n            if (key === 'events') {\n              for (let event in data.attributes.events) {\n                dom[event] = Parser.evaluateString(data.attributes.events[event], element);\n              }\n            } else {\n              const val = Parser.evaluateString(data.attributes[key], element);\n              updateAttribute$2(dom, key, val);\n            }\n          }\n        }\n        if (data.html === undefined) continue;\n        const newValue = Parser.evaluateString(data.text, element);\n        if (!newValue) {\n          dom.textContent = '';\n          continue;\n        }\n        if (data.html) {\n          let children;\n          if (Array.isArray(newValue)) {\n            children = newValue;\n          } else if (newValue.nodeType) {\n            children = [newValue];\n          } else {\n            TEMPLATE.innerHTML = newValue.toString()\n            .replace(/(&lt;)(((?!&gt;).)*)(&gt;)(((?!&lt;).)*)(&lt;)\\/(((?!&gt;).)*)(&gt;)/g, '<$2>$5</$8>')\n            .replace(/(&lt;)(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)(((?!&gt;).)*)(&gt;)/g, '<$2$3>');\n            children = Array.prototype.slice.call(TEMPLATE.content.childNodes);\n          }\n          if (children.length < 1) dom.textContent = '';else makeChildrenEqual$1(dom, children);\n        } else {\n          if (dom.nodeValue != newValue) {\n            dom.nodeValue = newValue;\n          }\n        }\n      }\n    },\n    twoWayBind: e => {\n      const target = e.path ? e.path[0] : e.target;\n      if (!target.dataset.sifrrBind) return;\n      const value = target.value === undefined ? target.innerHTML : target.value;\n      let state = {};\n      state[target.dataset.sifrrBind] = value;\n      target.getRootNode().host.state = state;\n    },\n    evaluateString: (string, element) => {\n      if (string.indexOf('${') < 0) return string;\n      string = string.trim();\n      if (string.match(/^\\${([^{}$]|{([^{}$])*})*}$/)) return replacer(string);\n      return replacer('`' + string + '`');\n      function replacer(match) {\n        if (match[0] == '$') match = match.slice(2, -1);\n        let f;\n        if (match.indexOf('return ') >= 0) {\n          f = new Function(match).bind(element);\n        } else {\n          f = new Function('return ' + match).bind(element);\n        }\n        return f();\n      }\n    }\n  };\n  var parser = Parser;\n\n  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var sifrr_fetch = createCommonjsModule(function (module, exports) {\n    /*! Sifrr.Fetch v0.0.1-alpha2 - sifrr project */\n    (function (global, factory) {\n      module.exports = factory();\n    })(commonjsGlobal, function () {\n      class Request {\n        constructor(type, url, options = {}) {\n          this.type = type;\n          this._options = options;\n          this._url = url;\n        }\n        get response() {\n          return window.fetch(this.url, this.options).then(resp => {\n            let contentType = resp.headers.get('content-type');\n            if (resp.ok) {\n              if (contentType && contentType.includes('application/json')) {\n                resp = resp.json();\n              }\n              return resp;\n            } else {\n              let error = Error(resp.statusText);\n              error.response = resp;\n              throw error;\n            }\n          });\n        }\n        get url() {\n          const params = this._options.params;\n          if (params && Object.keys(params).length > 0) {\n            return this._url + '?' + Object.keys(params).map(k => encodeURIComponent(k) + '=' + encodeURIComponent(params[k])).join('&');\n          } else {\n            return this._url;\n          }\n        }\n        get options() {\n          const options = Object.assign({\n            method: this.type,\n            mode: 'cors',\n            redirect: 'follow'\n          }, this._options);\n          options.headers = Object.assign({\n            'accept': 'application/json'\n          }, this._options.headers || {});\n          if (typeof options.body === 'object') {\n            options.body = JSON.stringify(options.body);\n          }\n          return options;\n        }\n      }\n      var request = Request;\n      class SifrrFetch {\n        static get(url, options = {}) {\n          return new request('GET', url, options).response;\n        }\n        static post(url, options = {}) {\n          return new request('POST', url, options).response;\n        }\n        static put(url, options = {}) {\n          return new request('PUT', url, options).response;\n        }\n        static delete(url, options = {}) {\n          return new request('DELETE', url, options).response;\n        }\n        static graphql(url, options = {}) {\n          const {\n            query,\n            variables = {}\n          } = options;\n          delete options.query;\n          delete options.variables;\n          options.headers = options.headers || {};\n          options.headers['Content-Type'] = 'application/json';\n          options.headers['Accept'] = 'application/json';\n          options.body = {\n            query,\n            variables\n          };\n          return new request('POST', url, options).response;\n        }\n        static file(url, options = {}) {\n          options.headers = options.headers || {};\n          options.headers.accept = options.headers.accept || '*/*';\n          return new request('GET', url, options).response;\n        }\n      }\n      var sifrr_fetch = SifrrFetch;\n      return sifrr_fetch;\n    });\n    /*! (c) @aadityataparia */\n  });\n\n  const {\n    TEMPLATE: TEMPLATE$1\n  } = constants;\n  class Loader {\n    constructor(elemName, config = {}) {\n      if (this.constructor.all[elemName]) return this.constructor.all[elemName].instance;\n      this.elementName = elemName;\n      this.config = config;\n      this.constructor.urls[elemName] = this.htmlUrl;\n    }\n    get html() {\n      const me = this;\n      if (this.constructor.all[this.elementName]) return this.constructor.all[this.elementName].html;\n      const html = sifrr_fetch.file(this.htmlUrl).then(resp => resp.text()).then(file => {\n        TEMPLATE$1.innerHTML = file;\n        return TEMPLATE$1.content;\n      }).then(html => {\n        Loader._all[me.elementName].template = html.querySelector('template');\n        return html;\n      });\n      Loader.add(me.elementName, {\n        instance: me,\n        html: html\n      });\n      return html;\n    }\n    get htmlUrl() {\n      return this.config.url || `${this.config.baseUrl || ''}/elements/${this.elementName.split('-').join('/')}.html`;\n    }\n    executeScripts() {\n      return this.html.then(file => {\n        file.querySelectorAll('script').forEach(script => {\n          const fxn = new Function(script.text).bind(window);\n          fxn();\n        });\n      });\n    }\n    static add(elemName, instance) {\n      Loader._all[elemName] = instance;\n    }\n    static get all() {\n      return Loader._all;\n    }\n  }\n  Loader._all = {};\n  Loader.urls = {};\n  var loader = Loader;\n\n  const {\n    collect: collect$2,\n    create: create$2\n  } = ref;\n  const {\n    TEMPLATE: TEMPLATE$2\n  } = constants;\n  function creator$1(node) {\n    if (node.nodeType !== 3) {\n      if (node.attributes !== undefined) {\n        const attrs = Array.from(node.attributes),\n              l = attrs.length;\n        const ret = [];\n        for (let i = 0; i < l; i++) {\n          const avalue = attrs[i].value;\n          if (avalue[0] === '$') {\n            ret.push({\n              name: attrs[i].name,\n              text: avalue.slice(2, -1)\n            });\n          }\n        }\n        if (ret.length > 0) return ret;\n      }\n      return 0;\n    } else {\n      let nodeData = node.nodeValue;\n      if (nodeData[0] === '$') {\n        node.nodeValue = '';\n        return nodeData.slice(2, -1);\n      }\n      return 0;\n    }\n  }\n  function updateState(simpleEl) {\n    const doms = simpleEl._refs,\n          refs = simpleEl.stateMap,\n          l = refs.length;\n    const newState = simpleEl.state,\n          oldState = simpleEl._oldState;\n    for (let i = 0; i < l; i++) {\n      const data = refs[i].ref,\n            dom = doms[i];\n      if (Array.isArray(data)) {\n        const l = data.length;\n        for (let i = 0; i < l; i++) {\n          const attr = data[i];\n          if (oldState[attr.text] !== newState[attr.text]) {\n            if (attr.name === 'class') dom.className = newState[attr.text] || '';else dom.setAttribute(attr.name, newState[attr.text]);\n          }\n        }\n      } else {\n        if (oldState[data] != newState[data]) dom.nodeValue = newState[data];\n      }\n    }\n  }\n  function SimpleElement(content, defaultState) {\n    if (typeof content === 'string') {\n      TEMPLATE$2.innerHTML = content;\n      content = TEMPLATE$2.content.firstElementChild || TEMPLATE$2.content.firstChild;\n      const oldDisplay = content.style.display;\n      content.style.display = 'none';\n      window.document.body.appendChild(content);\n      content.remove();\n      content.style.display = oldDisplay;\n    }\n    if (content.nodeName.indexOf('-') !== -1 || content.getAttribute('is') && content.getAttribute('is').indexOf('-') >= 0 || content.isSifrr && content.isSifrr()) return content;\n    content.stateMap = create$2(content, creator$1);\n    content._refs = collect$2(content, content.stateMap);\n    Object.defineProperty(content, 'state', {\n      get: () => content._state,\n      set: v => {\n        content._oldState = Object.assign({}, content._state);\n        content._state = Object.assign(content._state || {}, v);\n        updateState(content);\n      }\n    });\n    if (defaultState) content.state = defaultState;\n    content.sifrrClone = function (deep) {\n      const clone = content.cloneNode(deep);\n      clone.stateMap = content.stateMap;\n      clone._refs = collect$2(clone, content.stateMap);\n      Object.defineProperty(clone, 'state', {\n        get: () => clone._state,\n        set: v => {\n          clone._oldState = Object.assign({}, clone._state);\n          clone._state = Object.assign(clone._state || {}, v);\n          updateState(clone);\n        }\n      });\n      if (content.state) clone.state = content.state;\n      return clone;\n    };\n    return content;\n  }\n  var simpleelement = SimpleElement;\n\n  function elementClassFactory(baseClass) {\n    return class extends baseClass {\n      static extends(htmlElementClass) {\n        return elementClassFactory(htmlElementClass);\n      }\n      static get observedAttributes() {\n        return ['data-sifrr-state'].concat(this.observedAttrs());\n      }\n      static observedAttrs() {\n        return [];\n      }\n      static get template() {\n        return loader.all[this.elementName].template;\n      }\n      static get stateMap() {\n        this._stateMap = this._stateMap || parser.createStateMap(this.template.content);\n        return this._stateMap;\n      }\n      static get elementName() {\n        return this.name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n      }\n      static onStateChange() {}\n      static useSR() {\n        return this.template.getAttribute('use-shadow-root') !== 'false' && this.useShadowRoot;\n      }\n      constructor() {\n        super();\n        if (this.constructor.defaultState || this.state) this._state = Object.assign({}, this.constructor.defaultState, this.state);\n        const content = this.constructor.template.content.cloneNode(true);\n        if (this.constructor.useSR()) {\n          this._refs = parser.collectRefs(content, this.constructor.stateMap);\n          this.attachShadow({\n            mode: 'open'\n          });\n          this.shadowRoot.appendChild(content);\n          this.shadowRoot.addEventListener('change', parser.twoWayBind);\n        } else {\n          this.__content = content;\n        }\n      }\n      connectedCallback() {\n        if (!this.constructor.useSR()) {\n          this._refs = parser.collectRefs(this.__content, this.constructor.stateMap);\n          this.appendChild(this.__content);\n        }\n        if (!this.hasAttribute('data-sifrr-state') && this._state) this.update();\n        this.onConnect();\n      }\n      onConnect() {}\n      disconnectedCallback() {\n        if (this.useShadowRoot) this.shadowRoot.removeEventListener('change', parser.twoWayBind);\n        if (!this.constructor.useSR()) this.textContent = '';\n        this.onDisconnect();\n      }\n      onDisconnect() {}\n      attributeChangedCallback(attrName, oldVal, newVal) {\n        if (attrName === 'data-sifrr-state') {\n          this.state = json.parse(newVal);\n        }\n        this.onAttributeChange(attrName, oldVal, newVal);\n      }\n      onAttributeChange() {}\n      get state() {\n        return this._state;\n      }\n      set state(v) {\n        this._state = this._state || {};\n        Object.assign(this._state, v);\n        this.update();\n      }\n      update() {\n        parser.update(this);\n        this.onStateChange();\n        this.constructor.onStateChange(this);\n      }\n      onStateChange() {}\n      isSifrr(name = null) {\n        if (name) return name === this.constructor.elementName;else return true;\n      }\n      sifrrClone(deep) {\n        const clone = this.cloneNode(deep);\n        return clone;\n      }\n      clearState() {\n        this._state = {};\n        this.update();\n      }\n      $(args, sr = true) {\n        if (this.constructor.useShadowRoot && sr) return this.shadowRoot.querySelector(args);else return this.querySelector(args);\n      }\n      $$(args, sr = true) {\n        if (this.constructor.useShadowRoot && sr) return this.shadowRoot.querySelectorAll(args);else return this.querySelectorAll(args);\n      }\n      static addArrayToDom(key, template) {\n        this._arrayToDom = this._arrayToDom || {};\n        this._arrayToDom[this.elementName] = this._arrayToDom[this.elementName] || {};\n        this._arrayToDom[this.elementName][key] = simpleelement(template);\n      }\n      arrayToDom(key, newState = this.state[key]) {\n        this._domL = this._domL || {};\n        const oldL = this._domL[key] || 0;\n        const domArray = [];\n        const newL = newState.length;\n        let temp;\n        try {\n          temp = this.constructor._arrayToDom[this.constructor.elementName][key];\n        } catch (e) {\n          return window.console.log(`[error]: No arrayToDom data of '${key}' added in ${this.constructor.elementName}.`);\n        }\n        for (let i = 0; i < newL; i++) {\n          if (i < oldL) {\n            domArray.push({\n              type: 'stateChange',\n              state: newState[i]\n            });\n          } else {\n            const el = temp.sifrrClone(true);\n            el.state = newState[i];\n            domArray.push(el);\n          }\n        }\n        this._domL[key] = newL;\n        return domArray;\n      }\n    };\n  }\n  var element = elementClassFactory(window.HTMLElement);\n\n  const SYNTHETIC_EVENTS = {};\n  const nativeToSyntheticEvent = (e, name) => {\n    return Promise.resolve((() => {\n      let dom = e.path ? e.path[0] : e.target;\n      while (dom) {\n        const eventHandler = dom[`$${name}`];\n        if (eventHandler) {\n          eventHandler(e, dom);\n        }\n        cssMatchEvent(e, name, dom);\n        dom = dom.parentNode || dom.host;\n      }\n    })());\n  };\n  const cssMatchEvent = (e, name, dom) => {\n    function callEach(fxns) {\n      fxns.forEach(fxn => fxn(e, dom));\n    }\n    for (let css in SYNTHETIC_EVENTS[name]) {\n      if (typeof dom.matches === 'function' && dom.matches(css) || dom.nodeType === 9 && css === 'document') callEach(SYNTHETIC_EVENTS[name][css]);\n    }\n  };\n  const Event = {\n    add: name => {\n      if (SYNTHETIC_EVENTS[name]) return false;\n      window.document.addEventListener(name, event => nativeToSyntheticEvent(event, name), {\n        capture: true,\n        passive: true\n      });\n      SYNTHETIC_EVENTS[name] = {};\n      return true;\n    },\n    addListener: (name, css, fxn) => {\n      const fxns = SYNTHETIC_EVENTS[name][css] || [];\n      if (fxns.indexOf(fxn) < 0) fxns.push(fxn);\n      SYNTHETIC_EVENTS[name][css] = fxns;\n      return true;\n    },\n    removeListener: (name, css, fxn) => {\n      const fxns = SYNTHETIC_EVENTS[name][css] || [],\n            i = fxns.indexOf(fxn);\n      if (i >= 0) fxns.splice(i, 1);\n      SYNTHETIC_EVENTS[name][css] = fxns;\n      return true;\n    },\n    trigger: (el, name, options) => {\n      el.dispatchEvent(new window.Event(name, Object.assign({\n        bubbles: true,\n        composed: true\n      }, options)));\n    }\n  };\n  var event = Event;\n\n  let SifrrDom = {};\n  SifrrDom.elements = {};\n  SifrrDom.Element = element;\n  SifrrDom.Parser = parser;\n  SifrrDom.makeEqual = makeequal;\n  SifrrDom.Loader = loader;\n  SifrrDom.SimpleElement = simpleelement;\n  SifrrDom.Event = event;\n  SifrrDom.register = (Element, options) => {\n    Element.useShadowRoot = SifrrDom.config.useShadowRoot;\n    const name = Element.elementName;\n    if (!name) {\n      window.console.error('Error creating Custom Element: No name given.', Element);\n    } else if (window.customElements.get(name)) {\n      window.console.warn(`Error creating Element: ${name} - Custom Element with this name is already defined.`);\n    } else if (name.indexOf('-') < 1) {\n      window.console.error(`Error creating Element: ${name} - Custom Element name must have one dash '-'`);\n    } else {\n      try {\n        window.customElements.define(name, Element, options);\n        SifrrDom.elements[name] = Element;\n        return true;\n      } catch (error) {\n        window.console.error(`Error creating Custom Element: ${name} - ${error}`);\n        return false;\n      }\n    }\n    return false;\n  };\n  SifrrDom.setup = function (config) {\n    SifrrDom.config = Object.assign({\n      baseUrl: '',\n      useShadowRoot: true\n    }, config);\n    SifrrDom.Event.add('input');\n    SifrrDom.Event.add('change');\n    SifrrDom.Event.addListener('change', 'document', SifrrDom.Parser.twoWayBind);\n    SifrrDom.Event.addListener('input', 'document', SifrrDom.Parser.twoWayBind);\n  };\n  SifrrDom.load = function (elemName, config = {\n    baseUrl: SifrrDom.config.baseUrl\n  }) {\n    return new Promise((res, rej) => {\n      let loader$$1 = new SifrrDom.Loader(elemName, config);\n      loader$$1.executeScripts().then(() => res()).catch(() => rej());\n    });\n  };\n  SifrrDom.Url = url;\n  SifrrDom.Json = json;\n  SifrrDom.relativeTo = function (elemName, relativeUrl) {\n    if (typeof elemName === 'string') return SifrrDom.Url.absolute(SifrrDom.Loader.urls[elemName], relativeUrl);\n  };\n  var sifrr_dom = SifrrDom;\n\n  return sifrr_dom;\n\n})));\n/*! (c) @aadityataparia */\n//# sourceMappingURL=sifrr.dom.js.map\n","window.Sifrr = window.Sifrr || {};\nwindow.Sifrr.Dom = require('@sifrr/dom');\n\nconst Sifrr = window.Sifrr;\n\nSifrr.Dom.setup();\nSifrr.Dom.load('sifrr-route');\n"],"names":["url","URLExt","window","Sifrr","Dom","require$$0","setup","load"],"mappings":"sdAaQA,4EAOGA,2BAIMC,u5ZCxBjBC,OAAOC,MAAQD,OAAOC,OAAS,GAC/BD,OAAOC,MAAMC,IAAMC,EAEnB,MAAMF,EAAQD,OAAOC,MAErBA,EAAMC,IAAIE,QACVH,EAAMC,IAAIG,KAAK"}